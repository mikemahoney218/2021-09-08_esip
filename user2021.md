## Welcome

Hi everyone! I'm Mike Mahoney, and I'm excited to be talking to you today about using R as a frontend for producing beautiful landscape visualizations. I'm going to be focusing today on the terrainr R package as a way to retrieve spatial data for the United States and to visualize spatial data in the Unity 3D rendering engine, talk a little about the challenges of using these engines for data visualization, and then talk about why we think it's worthwhile to deal with those challenges and why we think R is the best language for the job.

## What's terrainr?

So, I want to walk through the basics of the terrainr package. I always think of terrainr as being composed of two distinct halves which can be used together or apart. The first half focuses on data access and retrieval, the second on visualization -- but importantly, each of those parts should work with any other tools you might want.

### Data retrieval

On the data retrieval side of things, terrainr provides a standard API to access public domain spatial data for the entire United States, with data provided by the United States Geological Survey's National Map. So say for instance you have some sf object -- here I've got a geoJSON file of campsites in Bryce Canyon National Park, out in Utah, which I'm just reading directly from a data portal. We can plot that with ggplot2, see how our campsites are arranged.

I can then pass that sf object directly to the `get_tiles` function from terrainr to download data from the National Map. So for the entire United States we have access to elevation data, accurate down to either 3 meters or 1 meter, depending where you're working, aerial orthoimagery at 1 meter resolution, and then a few other map tiles like contour lines and hydrography data. On the backend, these are all different services which you have to query in different ways, and there's a lot of code in terrainr dedicated to the unique querying, processing, and error handling each endpoint needs. 

But from the user's perspective, terrainr provides a single unified way to download the data. You just need to specify your area of interest and then use the services argument to specify whatever data you want. 

Here I'm also specifying that I want to download data at a 30 meter resolution -- one of the very nice things about the National Map is that it will resample its data to whatever resolution you're after, so if you're in an area with only 3 meter elevation data you can still request a 1 meter resolution image and make the government servers handle the resampling instead of doing it with your own CPU. And then the `get_tiles` function downloads the data and returns a list of where it's saved the files to.

And for a lot of users, that's what terrainr is -- it's an easy interface to free, public domain spatial data for the United States.

### Data Visualization

But I personally get excited about the other half of the package, which focuses on visualizing spatial data. So within R, it's already pretty easy to plot spatial data using either plotting methods from raster. For single band rasters, like our elevation data, we can use the simple plot method from raster; if we're trying to plot multi-band images -- so, images with red, blue, and green values for each pixel -- we can use plotRGB. And we can also bring the elevation into ggplot2 pretty easily using `geom_raster`. But it's a bit trickier to add multi-band images to ggplots, so we can do things like add our orthoimagery to a map.

So terrainr introduces a new geom, `geom_spatial_rgb`, to do exactly that. By providing either a RasterStack or a file that can be read in as a RasterStack, you can add arbitrary multi-band rasters to a ggplot. As you might guess from the name, this function was designed with spatial data in mind, but there's actually no requirement that you use the function for spatial data, since most image formats can be read in as a RasterStack object. That means this function is actually surprisingly flexible for adding any image to a ggplot, and I think there's a lot of interesting potential in off-label usage here that I'd expect future versions of terrainr to make a bit easier.

So that's how this package interacts with 2D visualizations. But also, R has a very active ecosystem for 3D spatial visualizations, especially in the past few years. And I think it's worth mentioning that the parts of terrainr we've talked about so far work pretty well with those -- for instance, we can use the awesome rayshader library to make beautiful visualizations of our 30 meter surface, plotted using rgl entirely within our R session.

terrainr offers another way to visualize these surfaces. Specifically, terrainr helps to transform data so that it can be brought into the Unity 3D game engine, producing these high-resolution, fully physically rendered terrain surfaces. Now, I want to talk about why we want to use game engines for this purpose, as well as the challenges in doing so, but I think it's useful to walk through how these visualizations are actually produced first.

First things first, we need to redownload our data at a 1 meter resolution. We could use any other data here -- any single band raster can be used as a heightmap, and any raster can be used as an image overlay -- but we'll stick with the same area for simplicity. This is a lot of data -- a few gigabytes -- so we'll actually download a number of tiles for our area of interest instead of the single files we were working with earlier. We can then use another terrainr function to merge those tiles into single files. Then we'll take those merged rasters and cut them into tiles that we can import into Unity. Our elevation tiles have to be transformed into a very specific binary format, which gets saved as a dot raw file, so the default argument raw = TRUE is fine there. Our orthoimagery doesn't need to be in that format, however, so we'll set raw to FALSE. 

That bit of code is enough to download our data tiles, merge them into larger files, and then transform the data for Unity. The only thing we have left to do is import the tiles into Unity. Now, in the very near future this is going to be handled by a function, but at the moment each tile needs to be brought in manually. The process is documented in a vignette in the package and takes me about three minutes, and afterwards we're left with a surface that looks something like this. And you can do this with any data -- any single-band raster can get turned into a heightmap, and any three-band raster can be turned into an image overlay.

## Why write frontends for third-party systems?

Now, I think this surface looks great, and it's pretty easy to produce this for any area you have data for. But I do think the obvious question looking at this process is: why bring in Unity at all? After all, Unity is not capital-f Free software -- it doesn't cost money, but it's not permissively licensed like R -- and interacting with Unity requires a completely separate skillset from the programming required to download and process spatial data. So why bother?

There's a couple of reasons. First off, Unity is designed to handle massive amounts of data without breaking a sweat. So for instance, here we've brought in an approximately 13 kilometer by 10 kilometer heightmap with about 130 million individual cells, each of which has a unique coloration and elevation. And I can use my keyboard and mouse to quickly skim over that entire surface without any stuttering or loading issues. Especially as I start moving faster, you can actually see how Unity manages this -- the areas closer to my camera are rendered in higher detail, with areas further away being rendered pretty simply until I get close. As a result, Unity can display absolutely massive high-resolution landscapes all at once, which can be a problem for tools rendering entirely within R.

Secondly, there's a lot of space to expand beyond these static surfaces in Unity. As I mentioned earlier, Unity is primarily used as a video game engine, and as such provides a lot of ways for users to interact with these scenes. Our landscape is actually physically rendered in the scene, so it will interact with other objects we add -- so by adding a small little script, I can actually create a "character" of sorts to walk across our surface, which potentially opens up a new way to add interactivity to 3D mapping applications. Now, at the moment adding characters requires a little bit of familiarity with the Unity UI, but we're planning on changing that; in the next few months, I hope to have a function to automatically create and add these characters on top of the world.

That's the main reason I think this is an interesting approach to landscape visualization -- Unity is an extremely powerful tool for visualization, but using it has typically required a completely different skillset than most other data analysis or visualization workflows. By building out ways to create visualizations in game engines from R, we can potentially make these tools more useful for scientific communication and improve the types of visualizations teams can actually take advantage of.

## Why use _R_ as a frontend?

Which brings me to the last question I mentioned -- why R? This is a new project and we could have chosen any language for our frontend, but there's a few reasons that made R the clear choice for us.

Well, one of the big challenges with using game engines for visualization is that these game engines don't think of "data" in the same way we might as scientists. The idea of trying to create data-defined landscapes in these systems is pretty new, and there isn't much tooling to support data import and manipulation in these engines. So having R's incredible data manipulation tools to help us create these scenes is a huge help, and the R package ecosystem is unmatched for this type of project. Plus, it's a huge benefit to be able to get ideas and inspiration from the incredible group of people working with spatial data and landscape visualization in R right now.

But even more than that, R is where our users are. We're working with terrainr and related projects to help ecologists and environmental scientists visualize the places they work in, to try and help promote qualitative understandings of large-scale systems. Those researchers are already broadly familiar with the R ecosystem, given just how prevalent R is in environmental research. If our goal is to make these visualizations more approachable, then we need to meet our users where they are. And so that's our goal with terrainr and the projects we have coming down the line -- we want to make it easy for users to apply their current R skills to make visualizations in Unity, without ever needing to think about why that might be a tricky thing to do.


